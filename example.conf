;
; We have communicators and monitors
;
; These are configured using the same options, which have different roles based on the return of 
; a given execution: everything is OK, WARNING, CRITICAL or INVALID
;
; As such a task is given as:
;
; type<n>:  classname
; args<n>:  class creation arguments
; {repeat,start,end,check_interval}<n>: timing control and monitoring variables
; invoke<n>:    what to do when task returns OK
; warn<n>:      what to do when task returns WARNING
; crit<n>:      what to do when task returns CRITICAL
; invalid<n>:   TODO
; *_args<n>:    class creation arguments for above behaviours
;
; TODO: determine if we need nested / recursive status action definitions (I'm thinking don't bother, but they'd be *_status)

[general]
log_level:      DEBUG

[communications]
type1:          rudics_comms
args1:  
    retries:    3
    retry_wait: 30
    min_signal: 3
    skip_on_warn:   1
start1:         1500
check_interval1:    2
end1:           1600
invoke1:        ssh_tunnel
invoke_args1:   address =   bslcenc.nerc-bas.ac.uk
                port    =   41892
                user    =   ggs

type2:          sbd_comms
args2:       
    retries:    5
    retry_wait: 60
    min_signal: 2
    path:       get_status
repeat2:        60

[monitor]
type1:          command
args1:          
    path:       get_battery_level
    warn:       50
    crit:       20
repeat1:        1
warn1:          sbd_comms
warn_args1:
    retries:    1
    min_signal: 2
    path:       get_warn_status
crit1:          goto_sleep


[modem]
port=/dev/ttyr07
timeout=60
baud=19200

