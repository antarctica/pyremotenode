;
; We have communicators and monitors
;
; These are configured using the same options, which have different roles based on the return of 
; a given execution: everything is OK, WARNING, CRITICAL or INVALID
;
; As such a task is given as:
;
; type<n>:  classname
; args<n>:  class creation arguments
; {repeat,start,end,check_interval}<n>: timing control and monitoring variables
; invoke<n>:    what to do when task returns OK
; warn<n>:      what to do when task returns WARNING
; crit<n>:      what to do when task returns CRITICAL
; invalid<n>:   TODO
; *_args<n>:    class creation arguments for above behaviours
;
; TODO: determine if we need nested / recursive status action definitions (I'm thinking don't bother, but they'd be *_status)

[general]
log_level:      DEBUG

[communications]
type1:          rudics_comms
args1:  
    retries:    3
    retry_wait: 30
    min_signal: 3
    skip_on_warn:   1
start1:         1624
check_interval1:    2
end1:           1630
invoke1:        ssh_tunnel
invoke_args1:   address =   bslcenc.nerc-bas.ac.uk
                port    =   41892
                user    =   ggs
                length  =   25

type2:          sbd_comms
args2:       
    retries:    5
    retry_wait: 60
    min_signal: 2
    path:       get_status
repeat2:        60

[monitor]
type1:          command
args1:          
    path:       get_battery_level
    warn:       50
    crit:       20
repeat1:        1
warn1:          sbd_comms
warn_args1:
    retries:    1
    min_signal: 2
    path:       get_warn_status
crit1:          command
crit_args1:
    path:       goto_sleep

type2:          command
args2:          
    path:       get_core_temperature 0
repeat2:        1
warn2:          sbd_comms
warn_args2:
    retries:    1
    min_signal: 2
    path:       get_warn_status
crit2:          command
crit_args2:
    path:       goto_sleep

type3:          command
args3:          
    path:       get_core_temperature 1 -w 20
repeat3:        1
warn3:          sbd_comms
warn_args3:
    retries:    1
    min_signal: 2
    path:       get_warn_status
crit3:          command
crit_args3:
    path:       goto_sleep

[modem]
port=/dev/ttyUSB0
timeout=60
baud=9600

;
; Scheduler behaviour
;
; The scheduler will have it's future events altered when monitors report the 
; state of the device as being undesirable - these actions should always be 
; configured reflecting on the potential scenarios programmed as actions for 
; individual events above
;

; This sets the behaviour of the scheduler should we experience
; a warning event
[warning]

; Likewise for critical events
[critical]
