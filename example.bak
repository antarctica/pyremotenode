;
; We have communicators and monitors
;
; These are configured using the same options, which have different roles based on the return of 
; a given execution: everything is OK, WARNING, CRITICAL or INVALID
;
; As such a task is given as:
;
; type<n>:  classname
; args<n>:  class creation arguments
; {repeat,start,end,check_interval}<n>: timing control and monitoring variables
; invoke<n>:    what to do when task returns OK
; warn<n>:      what to do when task returns WARNING
; crit<n>:      what to do when task returns CRITICAL
; invalid<n>:   TODO
; *_args<n>:    class creation arguments for above behaviours
;
; TODO: determine if we need nested / recursive status action definitions (I'm thinking don't bother, but they'd be *_status)

[general]
log_level:      DEBUG

[actions]
type1:          rudics_connection
args1:  
    retries:    3
    retry_wait: 30
    skip_on_warn:   1
start1:         2122
check_interval1:    1
end1:           2200
invoke1:        ssh_tunnel
invoke_args1:   address =   bslcenc.nerc-bas.ac.uk
                port    =   41892
                user    =   ggs
                length  =   25

type2:          sbd_message
args2:       
    retries:    5
    retry_wait: 60
    min_signal: 2
    path:       get_status
repeat2:        60

type3:          command
args3:
    path:       get_battery_level -w 50 -c 30
    warn:       50
    crit:       20
repeat3:        5
warn3:          sbd_message
warn_args3:
    retries:    1
    path:       get_warn_status
crit3:          command
crit_args3:
    path:       goto_sleep

[modem]
port=/tmp/ttyDUFF0
;timeout=60
baud=9600
